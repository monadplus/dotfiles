* Nix
** Core concepts

- *Nix expression*
- *Derivation*: language-independent recipe for how to build a path.
- *Build product*: anything in =/nix/store= that is not a derivation.
- =nix-build= combines =nix-instantiate= and =nix-store --realise=.

Instantiation: nix expression to derivation.

#+begin_src sh
$ nix-instantiate --expr --eval 'let pkgs = import <nixpkgs> {}; in pkgs.hello'
#+end_src

#+BEGIN_SRC sh
# Performs two steps:
# - evaluate the Nix expression to a derivation
# - creating the derivation file from the Nix expression
$ nix-instantiate --expr 'let pkgs = import <nixpkgs> { }; in pkgs.hello'
/nix/store/w3a5xqc8zjamz01qqnziwasalbkzyskc-hello-2.10.drv
#+END_SRC

Show a derivation:

#+BEGIN_SRC sh
$ nix show-derivation /nix/store/002dywnjxm4m857ni8wmvrz7d2xy4lx4-autoconf-2.69.drv
#+END_SRC

Show currently installed packages:

#+BEGIN_SRC sh
$ nix-env --query
#+END_SRC

Derivations are composed by:

- Input derivations (inputDrvs)
- Output derivations (outputs)
- Build instructions (builder/args/env)

Manual derivation:

#+BEGIN_SRC nix
derivation {
  name = "empty";
  system = "x86_64-linux"; # builtins.currentSystem;
  builder = ./exectuble;
}
#+END_SRC

Build a derivation:

#+BEGIN_SRC nix
nix-store --realise /nix/store/foo.drv
#+END_SRC

Query derivation's dependencies (build-time)

#+BEGIN_SRC nix
nix-store --query --tree /nix/store/foo.drv
#+END_SRC

** Tools
*** nix-shell

#+BEGIN_SRC nix
# shell.nix
{ pkgs ? import (fetchTarball "https://github.com/NixOS/nixpkgs/archive/3590f02e7d5760e52072c1a729ee2250b5560746.tar.gz") {} }:

pkgs.mkShell {
    buildInputs = [
        pkgs.which
        pkgs.htop
        pkgs.zlib
    ];


    # executed once you enter the nix-shell.
    shellHook = ''
        echo hello
    '';

    MY_ENVIRONMENT_VARIABLE = "world";
}
#+END_SRC

I recommend using =direnv= to automatically load your =shell.nix=

#+BEGIN_SRC sh
$ echo "use nix" > .envrc && direnv allow
#+END_SRC
*** nix repl

Its main use is to inspect values from nixpkgs.

#+BEGIN_SRC sh
nix repl '<nixpkgs>'

# Display all commands
nix-repl> :?

# Similar to "with"
nix-repl> :a builtins
nix-repl> attrNames { hello = 1; bye = 2; }

# Build a derivation and enter a nix-shell
nix-repl> :u pkgs.purescript
nix-shell> which purs

# Output path
nix-repl> :b pkgs.purescript
this derivation produced the following outputs:
  out -> /nix/store/vmwdvr9fcrbvnfdjfrrpb07z8gzbi1q7-purescript-0.13.0

# Install package to profile (not recommended)
nix-repl> :i pkgs.purescript

# Not very useful to work with individual derivations
$ nix repl default.nix # what is loaded?
nix-repl> src
nix-repl> outPath
# There isn't much more to do
nix-repl> :b import ./default.nix {}
#+END_SRC

*** nix-copy-closure
You can copy derivations, build products (shell.nix products included).

You can copy to/from.

**** shell.nix

The steps are the following:

#+begin_src sh
nix-build --no-out-link shell.nix -A inputDerivation
nix-store --query --references \
    /nix/store/rw6i1wk9iv0286xi2b6kpw4ynk4pldyh-example-shell

# Optional
scp shell.nix arnau@ip:~

# See issues below
nix-copy-closure --to arnau@ip \
    /nix/store/rw6i1wk9iv0286xi2b6kpw4ynk4pldyh-example-shell
#+end_src

***** Issues

During the =nix-copy-closure= step, we encountered the following errors:

- [[https://superuser.com/questions/1321059/nix-copy-closure-command-not-found-error/1321594][zsh:1: command not found: nix-store]]
- [[https://github.com/NixOS/nixpkgs/issues/37287][error: serialised integer 7161674624452356180 is too large for type 'j']]

To solve this you need to add the following text before your /ssh-rsa .../ in =~/.ssh/authorized_keys= in the host.

#+BEGIN_SRC sh
# Make sure .profile exist and references the .profile from ~/dotfiles
command=". ~/.profile; if [ -n \"$SSH_ORIGINAL_COMMAND\" ]; then eval \"$SSH_ORIGINAL_COMMAND\"; else exec \"$SHELL\"; fi"
#+END_SRC

*** nix-diff

https://github.com/Gabriel439/nix-diff

*** nixops

[[https://github.com/NixOS/nixops][GitHub - NixOS/nixops: NixOps is a tool for deploying to NixOS machines in a ...]]

*** nix-delegate

It executes a command on a remote machine (and copies back the results (?))

https://github.com/awakesecurity/nix-delegate

*** nix-deploy

Deploy a NixOS system configuration with nix-deploy system ... to a remote machine and switch the machine to that system configuration. You can also deploy a nix store path with nix-deploy path ... to a remote machine or from a remote machine.

- https://github.com/awakesecurity/nix-deploy
- [[https://awakesecurity.com/blog/deploy-software-easily-securely-using-nix-deploy/][Deploy software easily and securely using nix-deploy | Awake Security]]

*** hocker

- [[https://github.com/awakesecurity/hocker][GitHub - awakesecurity/hocker: Utilities for interacting with the docker regi...]]
- [[http://ixmatus.net/articles/docker-without-docker.html][Hocker, I can't believe it's not docker!]]
- [[http://ixmatus.net/articles/hocker-nixos-docker.html][Integration woes with docker containers and NixOS]]

*** lorri

[[https://github.com/target/lorri][GitHub - target/lorri: Your project's nix-env]]

*** niv

[[https://github.com/nmattia/niv][GitHub - nmattia/niv: Easy dependency management for Nix projects]]

#+BEGIN_SRC sh
$ niv init # create ./nix/
$ niv show # pinned dependencies

# add a package
$ nix add --help

# Change pinned nixpks
$ niv modify nixpkgs --branch nixos-20.09

# update all dependencies
$ niv update
#+END_SRC

Once =niv= is initialized, using it is really simple:

#+BEGIN_SRC nix
{ sources ? import ./nix/sources.nix
, pkgs ? import sources.nixpkgs {}
}:

...
#+END_SRC

*** gitignore.nix

Automated [[https://github.com/NixOS/nixpkgs/blob/d1bb36d5cb5b78111f799eb26f5f17e5979bc746/lib/sources.nix#L35-L67][cleanSourceWith]].

Filters a source tree removing version control files and directories.

Usage:

#+BEGIN_SRC nix
let
  gitignoreSrc = pkgs.fetchFromGitHub {
    owner = "hercules-ci";
    repo = "gitignore.nix";
    rev = "";
    sha256 = "";
  };
  inherit (import gitignoreSrc { inherit (pkgs) lib; }) gitignoreSource;
in
  mkDerivation {
    name = "hello";
    src = gitignoreSource ./vendored/hello;
  }
#+END_SRC

More info at [[https://github.com/hercules-ci/gitignore.nix][GitHub - hercules-ci/gitignore.nix: Nix function for filtering local git sources]]

*** cachix

Docs: [[https://docs.cachix.org/][Welcome to Cachix documentation â€” Cachix docs documentation]]

There are *public* and *private* caches.

There are *personal* and *per-cache* auth tokens.

**** Use a cache

#+BEGIN_SRC sh
cachix use <cache name>
#+END_SRC

**** Add a personal token

First, create a token https://app.cachix.org/personal-auth-tokens.

Then, add the token to cachix:

#+BEGIN_SRC sh
cachix authtoken <TOKEN>
CACHIX_AUTH_TOKEN=<TOKEN>
#+END_SRC

This will modify =~/.config/nix/nix.conf=.

#+BEGIN_SRC sh
$ cat ~/.config/nix/nix.conf
substituters = https://cache.nixos.org https://monadplus.cachix.org
trusted-public-keys = cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY= monadplus.cachix.org-1:+XFtvxGut8gfIXJtrA3plN9mZkgIHIDvYPCf+NEVd3c= monadplus.cachix.org-1:6WI9hyUuejM8qPoBAt8Ub29sC7GC2RHgIbLDpjAheCM=
#+END_SRC

Check cache exists:

#+BEGIN_SRC sh
$ curl https://monadplus.cachix.org/nix-cache-info
StoreDir: /nix/store
WantMassQuery: 1
Priority: 41
#+END_SRC

**** Add a per-cache token

Per-cache tokens are managed per cache in cachix.org https://app.cachix.org/cache/monadplus/settings/authtokens

**** Sign binaries

It is possible to sign binaries before pushing them.

https://docs.cachix.org/getting-started.html#signing-key-optional

**** Pushing binaries

#+BEGIN_SRC sh
$ nix-build | cachix push <cache name>
#+END_SRC

** Nix Pills

https://nixos.org/guides/nix-pills/index.html

*** Why You Should Give it a Try
*** Install on Your Running System

Nix has an sqlite database /nix/var/nix/db (schema = table of valid store path).

Never change /nix/store manually. If you do, then it will no longer be in sync with the sqlite db, unless you really know what you are doing.

If you change the location of the store i.e. /nix/store you won't benefit from nixos.org cache or any other binary cache since the paths will be different:

#+BEGIN_SRC sh
$ ldd /nix/store/9ywr69qi622lrmx5nn88gk8jpmihy0dz-bash-4.4-p23/bin/bash
    linux-vdso.so.1 (0x00007ffc9596d000)
    libdl.so.2 => /nix/store/0c7c96gikmzv87i7lv3vq5s1cmfjd6zf-glibc-2.31-74/lib/libdl.so.2 (0x00007fcc43022000)
    libc.so.6 => /nix/store/0c7c96gikmzv87i7lv3vq5s1cmfjd6zf-glibc-2.31-74/lib/libc.so.6 (0x00007fcc42e63000)
    /nix/store/0c7c96gikmzv87i7lv3vq5s1cmfjd6zf-glibc-2.31-74/lib/ld-linux-x86-64.so.2 => /usr/lib64/ld-linux-x86-64.so.2 (0x00007fcc43029000)
#+END_SRC

*** Enter the environment

What is adding nix binaries to the path?

#+BEGIN_SRC sh
# This file is sourced in ~/.profile
cat /home/arnau/.nix-profile/etc/profile.d/nix.sh
#+END_SRC

List generations:

#+BEGIN_SRC sh
$ nix-env --list-generations
    1   2021-03-31 12:14:49
    2   2021-03-31 13:38:53
    3   2021-03-31 14:39:25

$ home-manager generations
2021-05-03 21:38 : id 1 -> /nix/store/7kw9hbnlcbrckx61vx0cvhryrf7mz7pw-home-manager-generation
#+END_SRC

List installed derivations with path:

#+BEGIN_SRC sh
$ nix-env -q --out-path
#+END_SRC


#+BEGIN_SRC sh
# Dependencies of hello
nix-store -q --references `which hello`
/nix/store/v8q6nxyppy1myi3rxni2080bv8s9jxiy-glibc-2.32-40
/nix/store/544psc5aqpbmyffi7c6pgf8bhkkabkry-hello-2.10

# Reverse dependencies:
nix-store -q --referrers `which hello`
#+END_SRC

The =manifest.nix= file contains metadata about the environment, such as which derivations are installed.

The *closures* of a derivation is a list of all its dependencies, recursively, including absolutely everything necessary to use that derivation.

#+BEGIN_SRC sh
$ nix-store -qR `which hello`
/nix/store/q5g87xcw06a4cxsgf0bgmhpd8ipnk0nh-libunistring-0.9.10
/nix/store/jjhjkrll0n60bcczgldc4z6bmn2f24lc-libidn2-2.3.0
/nix/store/v8q6nxyppy1myi3rxni2080bv8s9jxiy-glibc-2.32-40
/nix/store/544psc5aqpbmyffi7c6pgf8bhkkabkry-hello-2.10

$ nix-store -q --tree `which man`
/nix/store/544psc5aqpbmyffi7c6pgf8bhkkabkry-hello-2.10
+---/nix/store/v8q6nxyppy1myi3rxni2080bv8s9jxiy-glibc-2.32-40
|   +---/nix/store/jjhjkrll0n60bcczgldc4z6bmn2f24lc-libidn2-2.3.0
|   |   +---/nix/store/q5g87xcw06a4cxsgf0bgmhpd8ipnk0nh-libunistring-0.9.10
|   |   |   +---/nix/store/q5g87xcw06a4cxsgf0bgmhpd8ipnk0nh-libunistring-0.9.10 [...]
|   |   +---/nix/store/jjhjkrll0n60bcczgldc4z6bmn2f24lc-libidn2-2.3.0 [...]
|   +---/nix/store/v8q6nxyppy1myi3rxni2080bv8s9jxiy-glibc-2.32-40 [...]
+---/nix/store/544psc5aqpbmyffi7c6pgf8bhkkabkry-hello-2.10 [...]
#+END_SRC

Copying all those derivations to the Nix store of another machine makes you able to run =hello= out of the box on that other machine.

*** The Basics of the Language


Simple Types: integer, floating point, string, path, boolean and null.

Complex Types: list, sets and functions.

*** Functions and Imports
*** Our first derivation

A *derivation* is an attribute set with:

- *system*: e.g. "i686-linux"
- *name*: string
- *builder*: derivation or source. Every attribute is passed to the builder as an envvar
  - Strings/Numbers
  - true as string "1". false and null as "".
  - Paths referenced file is copied to the store and passed to the builder as a nix store path.
  - Derivations are built and the output path is put into the environment.
  - List of previous types are allowed, passed by concatenation with whitespaces between values.
- *args* (optional): list of command line arguments to be passed to the builder.
- *outputs* (default "out"): list of symbolic outputs of the derivation e.g. outputs = [ "lib" "headers" "doc" ]; Outputs are build/downloaded separately e.g. pkg.lib, pkg.headers, ...
  - builder = ./configure --libdir=$lib/lib --includedir=$headers/include --docdir=$doc/share/doc
- ... (less used).

The type of a derivation set is derivation e.g. { type = "derivation"; }

*mkDerivation* wrapper around derivation:
- Default system.
- "bash" as the builder.

#+BEGIN_SRC sh
nix-repl> builtins.currentSystem
#+END_SRC

Notice the outpath is based only on the input drv. not the contents of the build product (i.e. content-addressable drv.)

#+BEGIN_SRC sh
$ nix show-derivation /nix/store/z3hhlxbckx4g3n9sw91nnvlkjvyw754p-myname.drv
{
  "/nix/store/z3hhlxbckx4g3n9sw91nnvlkjvyw754p-myname.drv": {
    "outputs": {
      "out": {
        "path": "/nix/store/40s0qmrfb45vlh6610rk29ym318dswdr-myname"
      }
    },
    "inputSrcs": [],
    "inputDrvs": {},
    "platform": "mysystem",
    "builder": "mybuilder",
    "args": [],
    "env": {
      "builder": "mybuilder",
      "name": "myname",
      "out": "/nix/store/40s0qmrfb45vlh6610rk29ym318dswdr-myname",
      "system": "mysystem"
    }
  }
}

# Build the derivation
$ nix-store -r /nix/store/z3hhlxbckx4g3n9sw91nnvlkjvyw754p-myname.drv
#+END_SRC

- *Instantiate/Evaluation time*: the Nix expression is parsed, interpreted and finally returns a derivation set. During evaluation, you can refer to other derivations because Nix will create .drv files and we will know out paths beforehand. This is achieved with nix-instantiate.
- *Realise/Build time*: the .drv from the derivation set is built, first building .drv inputs (build dependencies). This is achieved with nix-store -r.

*** Working Derivation

#+begin_src sh
# builder.sh
declare -xp
echo foo > $out

nix-repl> d = derivation { name = "foo"; builder = "${bash}/bin/bash"; args = [ ./builder.sh ]; system = builtins.currentSystem; }
nix-repl> :b d
these derivations will be built:
  /nix/store/i76pr1cz0za3i9r6xq518bqqvd2raspw-foo.drv
building '/nix/store/i76pr1cz0za3i9r6xq518bqqvd2raspw-foo.drv'...
declare -x HOME="/homeless-shelter"
declare -x NIX_BUILD_CORES="4"
declare -x NIX_BUILD_TOP="/tmp/nix-build-foo.drv-0"
declare -x NIX_LOG_FD="2"
declare -x NIX_STORE="/nix/store"
declare -x OLDPWD
declare -x PATH="/path-not-set"
declare -x PWD="/tmp/nix-build-foo.drv-0"
declare -x SHLVL="1"
declare -x TEMP="/tmp/nix-build-foo.drv-0"
declare -x TEMPDIR="/tmp/nix-build-foo.drv-0"
declare -x TMP="/tmp/nix-build-foo.drv-0"
declare -x TMPDIR="/tmp/nix-build-foo.drv-0"
declare -x builder="/nix/store/q1g0rl8zfmz7r371fp5p42p4acmv297d-bash-4.4-p19/bin/bash"
declare -x name="foo"
declare -x out="/nix/store/gczb4qrag22harvv693wwnflqy7lx5pb-foo"
declare -x system="x86_64-linux"
warning: you did not specify '--add-root'; the result might be removed by the garbage collector
/nix/store/gczb4qrag22harvv693wwnflqy7lx5pb-foo

this derivation produced the following outputs:
  out -> /nix/store/gczb4qrag22harvv693wwnflqy7lx5pb-foo


$ nix show-derivation /nix/store/i76pr1cz0za3i9r6xq518bqqvd2raspw-foo.drv
{
  "/nix/store/i76pr1cz0za3i9r6xq518bqqvd2raspw-foo.drv": {
    "outputs": {
      "out": {
        "path": "/nix/store/gczb4qrag22harvv693wwnflqy7lx5pb-foo"
      }
    },
    "inputSrcs": [
      "/nix/store/lb0n38r2b20r8rl1k45a7s4pj6ny22f7-builder.sh"
    ],
    "inputDrvs": {
      "/nix/store/hcgwbx42mcxr7ksnv0i1fg7kw6jvxshb-bash-4.4-p19.drv": [
        "out"
      ]
    },
    "platform": "x86_64-linux",
    "builder": "/nix/store/q1g0rl8zfmz7r371fp5p42p4acmv297d-bash-4.4-p19/bin/bash",
    "args": [
      "/nix/store/lb0n38r2b20r8rl1k45a7s4pj6ny22f7-builder.sh"
    ],
    "env": {
      "builder": "/nix/store/q1g0rl8zfmz7r371fp5p42p4acmv297d-bash-4.4-p19/bin/bash",
      "name": "foo",
      "out": "/nix/store/gczb4qrag22harvv693wwnflqy7lx5pb-foo",
      "system": "x86_64-linux"
    }
  }
}
#+end_src

Packaging a simple C program

#+begin_src sh
# simple.c
void main() {
  puts("Simple!");
}

# simple_builder.sh
export PATH="$coreutils/bin:$gcc/bin"
mkdir $out
gcc -o $out/simple $src

nix-repl> :l <nixpkgs>
nix-repl> simple = derivation { name = "simple"; builder = "${bash}/bin/bash"; args = [ ./simple_builder.sh ]; gcc = gcc; coreutils = coreutils; src = ./simple.c; system = builtins.currentSystem; }
nix-repl> :b simple
this derivation produced the following outputs:

  out -> /nix/store/ni66p4jfqksbmsl616llx3fbs1d232d4-simple
#+end_src

#+begin_src sh
# simple.nix
# nix-build simple.nix  # nix-instantitate + nix-store -r
with (import <nixpkgs> {});
derivation {
  name = "simple";
  builder = "${bash}/bin/bash";
  args = [ ./simple_builder.sh ];
  inherit gcc coreutils;
  src = ./simple.c;
  system = builtins.currentSystem;
}
#+end_src

*** Generic Builders

[[http://ftp.gnu.org/gnu/hello/hello-2.10.tar.gz][GNU hello world tar]]

#+begin_src sh
# hello_builder.sh
export PATH="$gnutar/bin:$gcc/bin:$gnumake/bin:$coreutils/bin:$gawk/bin:$gzip/bin:$gnugrep/bin:$gnused/bin:$binutils/bin"
tar -xzf $src
cd hello-2.10
./configure --prefix=$out
make
make install

# hello.nix
with (import <nixpkgs> {});
derivation {
  name = "hello";
  builder = "${bash}/bin/bash";
  args = [ ./hello_builder.sh ];
  inherit gnutar gzip gnumake gcc coreutils gawk gnused gnugrep;
  binutils = binutils-unwrapped;
  src = ./hello-2.10.tar.gz;
  system = builtins.currentSystem;
}
#+end_src

Let's create a generic builder.sh for autotools (hello is an example) projects:

#+begin_src sh
# builder.sh

# Exit on error
set -e
unset PATH
for p in $buildInputs; do
  export PATH=$p/bin${PATH:+:}$PATH
done

tar -xf $src

# Find unpacked src directory
for d in *; do
  if [ -d "$d" ]; then
    cd "$d"
    break
  fi
done

./configure --prefix=$out
make
make install

# hello.nix
with (import <nixpkgs> {});
derivation {
  name = "hello";
  builder = "${bash}/bin/bash";
  args = [ ./builder.sh ];
  buildInputs = [ gnutar gzip gnumake gcc binutils-unwrapped coreutils gawk gnused gnugrep ];
  src = ./hello-2.10.tar.gz;
  system = builtins.currentSystem;
}
#+end_src

mkDerivation like:

#+begin_src sh
# autotools.nix
pkgs: attrs:
  with pkgs;
  let defaultAttrs = {
    builder = "${bash}/bin/bash";
    args = [ ./builder.sh ];
    baseInputs = [ gnutar gzip gnumake gcc binutils-unwrapped coreutils gawk gnused gnugrep ];
    buildInputs = [];
    system = builtins.currentSystem;
  };
  in
  derivation (defaultAttrs // attrs)

# hello.nix
let
  pkgs = import <nixpkgs> {};
  mkDerivation = import ./autotools.nix pkgs;
in mkDerivation {
  name = "hello";
  src = ./hello-2.10.tar.gz;
}
#+end_src

*** Automatic Runtime Dependencies

TODO https://nixos.org/guides/nix-pills/automatic-runtime-dependencies.html

*** Developing with nix-shell
*** Garbage Collector
*** Inputs Design Pattern
*** Callpackage Design Pattern
*** Override Design Pattern
*** Nix Search Paths
*** Nixpkgs Parameters
*** Nixpkgs Overriding Packages
*** Nix Store paths
*** Fundamentals of Stdenv
*** Basic Dependencies and Hooks

** Tips & Tricks

*** Install/Uninstall a package

Install:

#+BEGIN_SRC
$ nix-env -iA nixpkgs.myGHC
$ nix-env -f '<nixpkgs-stable>' -iA myGHC
#+END_SRC

Uninstall:

#+BEGIN_SRC
$ nix-env -e '<name of the derivation>'
$ nix-env -e '.*haskell.*'
#+END_SRC

*** Update all packages:

#+begin_src
nix-channel --update nixpkgs
nix-env -u '*'
#+end_src

*** nix shebangs

#+BEGIN_SRC bash
#! /usr/bin/env nix-shell
#! nix-shell --pure -i python -p "python38.withPackages (ps: [ ps.django ])"
#! nix-shell -I nixpkgs=https://github.com/NixOS/nixpkgs/archive/82b5f87fcc710a99c47c5ffe441589807a8202af.tar.gz

...
#+END_SRC

*** The default script for each phase is defined in the file =pkgs/stdenv/generic/setup.sh=.
*** See the sources of a package:

#+BEGIN_SRC sh
$ nix edit -f '<nixpkgs>' hello
#+END_SRC

*** Print runtime dependencies of a closure:

#+BEGIN_SRC sh
$ nix-store -qR $(which svn)
#+END_SRC

*** Get a haskell package version:

#+BEGIN_SRC sh
$ nix-instantiate '<nixpkgs>' --eval --strict --attr haskellPackages.hocker.version
#+END_SRC

*** =patchShebangs=, =makeWrapper=, etc

https://github.com/NixOS/nixpkgs/tree/master/pkgs/build-support/setup-hooks
*** <nixpkgs>

<path> looks for nix expressions specified by =$NIX_PATH= (similar to =$PATH=).

#+BEGIN_SRC sh
$ echo $NIX_PATH
/home/arnau/.nix-defexpr/channels:/home/arnau/.nix-defexpr/channels:/home/arnau/.nix-defexpr/channels
#+END_SRC

*** Custom environment using =packageOverrides=

#+begin_src nix
# $ nix-shell <file> -A myPackages
let config = {
  packageOverrides = pkgs: with pkgs; {
      myPackages = pkgs.buildEnv {
        name = "foo";
        paths = [
          nox
        ];
        pathsToLink = [ "/share" "/bin" ];
      };
    };
  };
  pkgs = import <nixpkgs> { inherit config; };

in pkgs
#+end_src

*** Building and running Docker images

#+BEGIN_SRC nix
{ pkgs ? import <nixpkgs> { system = "x86_64-linux"; } }:

pkgs.dockerTools.buildImage {
  name = "hello-docker";
  config = { Cmd = [ "${pkgs.hello}/bin/hello" ]; };
}
#+END_SRC

Run the container:


#+BEGIN_SRC sh
$ nix-build
$ docker load < result # $ docker load < $(nix-build)
Loaded image: hello-docker:y74sb4nrhxr975xs7h83izgm8z75x5fc
$ docker run -t hello-docker:y74sb4nrhxr975xs7h83izgm8z75x5fc
#+END_SRC

More info at:

- [[https://nixos.org/manual/nixpkgs/stable/#sec-pkgs-dockerTools][dockerTools]]
- [[https://github.com/NixOS/nixpkgs/blob/master/pkgs/build-support/docker/examples.nix][dockerTools examples]]

*** Deploying NixOS using Terraform

[[https://nix.dev/tutorials/deploying-nixos-using-terraform.html][Deploying NixOS using Terraform â€” nix.dev documentation]]

*** Nix profile

=~/.nix-profile/bin= is in your PATH

=nix-env= only changes where the ~/.nix-profile softlink points.

#+BEGIN_SRC sh
$ readlink ~/.nix-profile
/nix/var/nix/profiles/per-user/arnau/profile

$ readlink -f ~/.nix-profile
/nix/store/snyws5v4z4cgirj5rnj8b63mhqgx14kp-user-environment
#+END_SRC

*** My first derivation

- To build: =$ nix-build default.nix=
- To install: =$ nix-env -i -f default.nix=

#+BEGIN_SRC nix
# default.nix
{ pkgs ? import <nixpkgs> {} }:

pkgs.stdenv.mkDerivation {
  name = "test.txt";
  src = ./test.txt;
  phases = [ "installPhase" ];
  installPhase = ''
    ln -s $src $out
  '';
}
#+END_SRC

*** Recovering after deleting nix accidentally

#+BEGIN_SRC sh
$ ls /nix/store/*nix-2.3.10
$ /nix/store/wixxr1fn5r1jhaw6xyxnm78jcwmsdj5g-nix-2.3.10/bin/nix-env --rollback
#+END_SRC

** Anti-patterns

*** Unquoted URLs are bad
*** rec can loop, use let ... in
*** with attrset; .. expression

#+BEGIN_SRC nix
# instead of:
with (import <nixpkgs> {});

# try this instead:
let
  pkgs = import <nixpkgs> {};
  inherit (pkgs) curl jq;
in ...
#+END_SRC

#+BEGIN_SRC nix
# instead of:
buildInputs = with pkgs; [ curl jq ];

# try this instead:
buildInputs = builtins.attrValues {
  inherit (pkgs) curl jq;
};

# or this:
buildInputs = lib.attrVals ["curl" "jq"] pkgs
#+END_SRC

*** Pin, do not <nixpkgs>
*** attr1 // attr2

Does not work on nested attrsets:

#+BEGIN_SRC
nix-repl> :p { a = { b = 1; }; } // { a = { c = 3; }; }
{ a = { c = 3; }; }
#+END_SRC

A better way =pkgs.lib.recursiveUpdate=:

#+BEGIN_SRC
:p pkgs.lib.recursiveUpdate { a = { b = 1; }; } { a = { c = 3; }; }
{ a = { b = 1; c = 3; }; }
#+END_SRC

*** src = ./. is not reproducible


#+BEGIN_SRC nix
{ pkgs ? import <nixpkgs> {} }:

pkgs.stdenv.mkDerivation {
   name = "foobar";
   src = ./.;
}
#+END_SRC

The problem is that now your build is *no longer reproducible*, as it depends on the parent directory name.

#+BEGIN_SRC nix
{ pkgs ? import <nixpkgs> {} }:

pkgs.stdenv.mkDerivation {
   name = "foobar";
   src = builtins.path { path = ./.; name = "myproject"; };
}
#+END_SRC

** Resources

Manuals:

- [[https://nixos.org/manual/nix/stable/][Nix (manual)]]
- [[https://nixos.org/manual/nixos/stable/][NixOS (manual)]]
- [[https://nixos.org/manual/nixpkgs/stable/][Nixpkgs (manual)]]
- [[https://hydra.nixos.org/build/141547278/download/1/hydra/][Hydra (manual)]]

Guide:

- https://nix.dev/index.html
- https://github.com/nix-dot-dev/getting-started-nix-template

*** Nix

- [[https://github.com/Gabriel439/slides/blob/master/nix-internals/slides.md][nix-internals (Gabriel Gonzalez)]]

*** Nixpkgs

- [[https://discourse.nixos.org/t/difference-between-fetchtarball-fetchfromgithub-fetchgit/3279][fetchTarball vs fetchGit vs fetchFromGithub]]
- [[https://blog.flyingcircus.io/2017/11/07/nixos-the-dos-and-donts-of-nixpkgs-overlays/][The DOs and DONâ€™Ts of nixpkgs overlays]]

**** Tutorials

- [[https://github.com/Gabriel439/haskell-nix][Nix and Haskell in production]] How to develop and build your haskell applications using Nix.
- [[https://github.com/fghibellini/nix-haskell-monorepo][Nix Haskell Monorepo Tutorial]] Recommended after /Nix and Haskell in production/)

*** NixOS

- [[https://nixos.wiki/wiki/Configuration_Collection][Collection of configurations]]
- [[https://github.com/nix-community/home-manager][Home Manager]]
- [[http://www.haskellforall.com/2018/08/nixos-in-production.html][NixOS in production]] short post summarizing what I wish I had known when I first started using NixOS in production
- [[https://awakesecurity.com/blog/deploy-software-easily-securely-using-nix-deploy/][Deploy software easily and securely using nix-deploy]]
