* Nix

** Core concepts

- *Nix expression*
- *Derivation*: language-independent recipe for how to build a path.
- *Build product*: anything in =/nix/store= that is not a derivation.
- =nix-build= combines =nix-instantiate= and =nix-store --realise=.

Instantiation: nix expression to derivation.

#+begin_src sh
$ nix-instantiate --expr --eval 'let pkgs = import <nixpkgs> {}; in pkgs.hello'
#+end_src

#+BEGIN_SRC sh
# Performs two steps:
# - evaluate the Nix expression to a derivation
# - creating the derivation file from the Nix expression
$ nix-instantiate --expr 'let pkgs = import <nixpkgs> { }; in pkgs.hello'
/nix/store/w3a5xqc8zjamz01qqnziwasalbkzyskc-hello-2.10.drv
#+END_SRC

Show a derivation:

#+BEGIN_SRC sh
$ nix show-derivation /nix/store/002dywnjxm4m857ni8wmvrz7d2xy4lx4-autoconf-2.69.drv
#+END_SRC

Show currently installed packages:

#+BEGIN_SRC sh
$ nix-env --query
#+END_SRC

Derivations are composed by:

- Input derivations (inputDrvs)
- Output derivations (outputs)
- Build instructions (builder/args/env)

Manual derivation:

#+BEGIN_SRC nix
derivation {
  name = "empty";
  system = "x86_64-linux"; # builtins.currentSystem;
  builder = ./exectuble;
}
#+END_SRC

Build a derivation:

#+BEGIN_SRC nix
nix-store --realise /nix/store/foo.drv
#+END_SRC

Query derivation's dependencies (build-time)

#+BEGIN_SRC nix
nix-store --query --tree /nix/store/foo.drv
#+END_SRC

** Tools
*** nix-shell

#+BEGIN_SRC nix
# shell.nix
{ pkgs ? import (fetchTarball "https://github.com/NixOS/nixpkgs/archive/3590f02e7d5760e52072c1a729ee2250b5560746.tar.gz") {} }:

pkgs.mkShell {
    buildInputs = [
        pkgs.which
        pkgs.htop
        pkgs.zlib
    ];


    # executed once you enter the nix-shell.
    shellHook = ''
        echo hello
    '';

    MY_ENVIRONMENT_VARIABLE = "world";
}
#+END_SRC

I recommend using =direnv= to automatically load your =shell.nix=

#+BEGIN_SRC sh
$ echo "use nix" > .envrc && direnv allow
#+END_SRC
*** nix repl

Its main use is to inspect values from nixpkgs.

#+BEGIN_SRC sh
nix repl '<nixpkgs>'

# Display all commands
nix-repl> :?

# Similar to "with"
nix-repl> :a builtins
nix-repl> attrNames { hello = 1; bye = 2; }

# Build a derivation and enter a nix-shell
nix-repl> :u pkgs.purescript
nix-shell> which purs

# Output path
nix-repl> :b pkgs.purescript
this derivation produced the following outputs:
  out -> /nix/store/vmwdvr9fcrbvnfdjfrrpb07z8gzbi1q7-purescript-0.13.0

# Install package to profile (not recommended)
nix-repl> :i pkgs.purescript

# Not very useful to work with individual derivations
$ nix repl default.nix # what is loaded?
nix-repl> src
nix-repl> outPath
# There isn't much more to do
nix-repl> :b import ./default.nix {}
#+END_SRC

*** nix-copy-closure
You can copy derivations, build products (shell.nix products included).

You can copy to/from.

**** shell.nix

The steps are the following:

#+begin_src sh
nix-build --no-out-link shell.nix -A inputDerivation
nix-store --query --references \
    /nix/store/rw6i1wk9iv0286xi2b6kpw4ynk4pldyh-example-shell

# Optional
scp shell.nix arnau@ip:~

# See issues below
nix-copy-closure --to arnau@ip \
    /nix/store/rw6i1wk9iv0286xi2b6kpw4ynk4pldyh-example-shell
#+end_src

***** Issues

During the =nix-copy-closure= step, we encountered the following errors:

- [[https://superuser.com/questions/1321059/nix-copy-closure-command-not-found-error/1321594][zsh:1: command not found: nix-store]]
- [[https://github.com/NixOS/nixpkgs/issues/37287][error: serialised integer 7161674624452356180 is too large for type 'j']]

To solve this you need to add the following text before your /ssh-rsa .../ in =~/.ssh/authorized_keys= in the host.

#+BEGIN_SRC sh
# Make sure .profile exist and references the .profile from ~/dotfiles
command=". ~/.profile; if [ -n \"$SSH_ORIGINAL_COMMAND\" ]; then eval \"$SSH_ORIGINAL_COMMAND\"; else exec \"$SHELL\"; fi"
#+END_SRC

*** nix-diff

https://github.com/Gabriel439/nix-diff

*** nixops

[[https://github.com/NixOS/nixops][GitHub - NixOS/nixops: NixOps is a tool for deploying to NixOS machines in a ...]]

*** nix-delegate

It executes a command on a remote machine (and copies back the results (?))

https://github.com/awakesecurity/nix-delegate

*** nix-deploy

Deploy a NixOS system configuration with nix-deploy system ... to a remote machine and switch the machine to that system configuration. You can also deploy a nix store path with nix-deploy path ... to a remote machine or from a remote machine.

- https://github.com/awakesecurity/nix-deploy
- [[https://awakesecurity.com/blog/deploy-software-easily-securely-using-nix-deploy/][Deploy software easily and securely using nix-deploy | Awake Security]]

*** hocker

- [[https://github.com/awakesecurity/hocker][GitHub - awakesecurity/hocker: Utilities for interacting with the docker regi...]]
- [[http://ixmatus.net/articles/docker-without-docker.html][Hocker, I can't believe it's not docker!]]
- [[http://ixmatus.net/articles/hocker-nixos-docker.html][Integration woes with docker containers and NixOS]]

*** lorri

[[https://github.com/target/lorri][GitHub - target/lorri: Your project's nix-env]]

*** niv

[[https://github.com/nmattia/niv][GitHub - nmattia/niv: Easy dependency management for Nix projects]]

#+BEGIN_SRC sh
$ niv init # create ./nix/
$ niv show # pinned dependencies

# add a package
$ nix add --help

# Change pinned nixpks
$ niv modify nixpkgs --branch nixos-20.09

# update all dependencies
$ niv update
#+END_SRC

Once =niv= is initialized, using it is really simple:

#+BEGIN_SRC nix
{ sources ? import ./nix/sources.nix
, pkgs ? import sources.nixpkgs {}
}:

...
#+END_SRC

*** gitignore.nix

Automated [[https://github.com/NixOS/nixpkgs/blob/d1bb36d5cb5b78111f799eb26f5f17e5979bc746/lib/sources.nix#L35-L67][cleanSourceWith]].

Filters a source tree removing version control files and directories.

Usage:

#+BEGIN_SRC nix
let
  gitignoreSrc = pkgs.fetchFromGitHub {
    owner = "hercules-ci";
    repo = "gitignore.nix";
    rev = "";
    sha256 = "";
  };
  inherit (import gitignoreSrc { inherit (pkgs) lib; }) gitignoreSource;
in
  mkDerivation {
    name = "hello";
    src = gitignoreSource ./vendored/hello;
  }
#+END_SRC

More info at [[https://github.com/hercules-ci/gitignore.nix][GitHub - hercules-ci/gitignore.nix: Nix function for filtering local git sources]]

*** cachix

Docs: [[https://docs.cachix.org/][Welcome to Cachix documentation — Cachix docs documentation]]

There are *public* and *private* caches.

There are *personal* and *per-cache* auth tokens.

**** Use a cache

#+BEGIN_SRC sh
cachix use <cache name>
#+END_SRC

**** Add a personal token

First, create a token https://app.cachix.org/personal-auth-tokens.

Then, add the token to cachix:

#+BEGIN_SRC sh
cachix authtoken <TOKEN>
CACHIX_AUTH_TOKEN=<TOKEN>
#+END_SRC

This will modify =~/.config/nix/nix.conf=.

#+BEGIN_SRC sh
$ cat ~/.config/nix/nix.conf
substituters = https://cache.nixos.org https://monadplus.cachix.org
trusted-public-keys = cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY= monadplus.cachix.org-1:+XFtvxGut8gfIXJtrA3plN9mZkgIHIDvYPCf+NEVd3c= monadplus.cachix.org-1:6WI9hyUuejM8qPoBAt8Ub29sC7GC2RHgIbLDpjAheCM=
#+END_SRC

Check cache exists:

#+BEGIN_SRC sh
$ curl https://monadplus.cachix.org/nix-cache-info
StoreDir: /nix/store
WantMassQuery: 1
Priority: 41
#+END_SRC

**** Add a per-cache token

Per-cache tokens are managed per cache in cachix.org https://app.cachix.org/cache/monadplus/settings/authtokens

**** Sign binaries

It is possible to sign binaries before pushing them.

https://docs.cachix.org/getting-started.html#signing-key-optional

**** Pushing binaries

#+BEGIN_SRC sh
$ nix-build | cachix push <cache name>
#+END_SRC

** Nix Pills

https://nixos.org/guides/nix-pills/index.html

*** Why You Should Give it a Try
*** Install on Your Running System

Nix has an sqlite database /nix/var/nix/db (schema = table of valid store path).

Never change /nix/store manually. If you do, then it will no longer be in sync with the sqlite db, unless you really know what you are doing.

If you change the location of the store i.e. /nix/store you won't benefit from nixos.org cache or any other binary cache since the paths will be different:

#+BEGIN_SRC sh
$ ldd /nix/store/9ywr69qi622lrmx5nn88gk8jpmihy0dz-bash-4.4-p23/bin/bash
    linux-vdso.so.1 (0x00007ffc9596d000)
    libdl.so.2 => /nix/store/0c7c96gikmzv87i7lv3vq5s1cmfjd6zf-glibc-2.31-74/lib/libdl.so.2 (0x00007fcc43022000)
    libc.so.6 => /nix/store/0c7c96gikmzv87i7lv3vq5s1cmfjd6zf-glibc-2.31-74/lib/libc.so.6 (0x00007fcc42e63000)
    /nix/store/0c7c96gikmzv87i7lv3vq5s1cmfjd6zf-glibc-2.31-74/lib/ld-linux-x86-64.so.2 => /usr/lib64/ld-linux-x86-64.so.2 (0x00007fcc43029000)
#+END_SRC

*** Enter the environment

What is adding nix binaries to the path?

#+BEGIN_SRC sh
# This file is sourced in ~/.profile
cat /home/arnau/.nix-profile/etc/profile.d/nix.sh
#+END_SRC

List generations:

#+BEGIN_SRC sh
$ nix-env --list-generations
    1   2021-03-31 12:14:49
    2   2021-03-31 13:38:53
    3   2021-03-31 14:39:25

$ home-manager generations
2021-05-03 21:38 : id 1 -> /nix/store/7kw9hbnlcbrckx61vx0cvhryrf7mz7pw-home-manager-generation
#+END_SRC

List installed derivations with path:

#+BEGIN_SRC sh
$ nix-env -q --out-path
#+END_SRC

Runtime dependencies of hello:

#+BEGIN_SRC sh
nix-store -q --references `which cachix`
#+END_SRC

*** The Basics of the Language
*** Functions and Imports
*** Our first derivation
*** Working Derivation
*** Generic Builders
*** Automatic Runtime Dependencies
*** Developing with nix-shell
*** Garbage Collector
*** Inputs Design Pattern
*** Callpackage Design Pattern
*** Override Design Pattern
*** Nix Search Paths
*** Nixpkgs Parameters
*** Nixpkgs Overriding Packages
*** Nix Store paths
*** Fundamentals of Stdenv
*** Basic Dependencies and Hooks

** Tips & Tricks

*** Install/Uninstall a package

Install:

#+BEGIN_SRC
$ nix-env -iA nixpkgs.myGHC
$ nix-env -f '<nixpkgs-stable>' -iA myGHC
#+END_SRC

Uninstall:

#+BEGIN_SRC
$ nix-env -e '<name of the derivation>'
$ nix-env -e '.*haskell.*'
#+END_SRC

*** Update all packages:

#+begin_src
nix-channel --update nixpkgs
nix-env -u '*'
#+end_src

*** nix shebangs

#+BEGIN_SRC bash
#! /usr/bin/env nix-shell
#! nix-shell --pure -i python -p "python38.withPackages (ps: [ ps.django ])"
#! nix-shell -I nixpkgs=https://github.com/NixOS/nixpkgs/archive/82b5f87fcc710a99c47c5ffe441589807a8202af.tar.gz

...
#+END_SRC

*** The default script for each phase is defined in the file =pkgs/stdenv/generic/setup.sh=.
*** See the sources of a package:

#+BEGIN_SRC sh
$ nix edit -f '<nixpkgs>' hello
#+END_SRC

*** Print runtime dependencies of a closure:

#+BEGIN_SRC sh
$ nix-store -qR $(which svn)
#+END_SRC

*** Get a haskell package version:

#+BEGIN_SRC sh
$ nix-instantiate '<nixpkgs>' --eval --strict --attr haskellPackages.hocker.version
#+END_SRC

*** =patchShebangs=, =makeWrapper=, etc

https://github.com/NixOS/nixpkgs/tree/master/pkgs/build-support/setup-hooks
*** How <nixpkgs> works (do not use)

<path> looks for nix expressions specified by =$NIX_PATH= (similar to =$PATH=).

#+BEGIN_SRC sh
$ echo $NIX_PATH
/home/arnau/.nix-defexpr/channels:/home/arnau/.nix-defexpr/channels:/home/arnau/.nix-defexpr/channels
#+END_SRC

*** Custom environment using =packageOverrides=

#+begin_src nix
# $ nix-shell <file> -A myPackages
let config = {
  packageOverrides = pkgs: with pkgs; {
      myPackages = pkgs.buildEnv {
        name = "foo";
        paths = [
          nox
        ];
        pathsToLink = [ "/share" "/bin" ];
      };
    };
  };
  pkgs = import <nixpkgs> { inherit config; };

in pkgs
#+end_src

*** Building and running Docker images

#+BEGIN_SRC nix
{ pkgs ? import <nixpkgs> { system = "x86_64-linux"; } }:

pkgs.dockerTools.buildImage {
  name = "hello-docker";
  config = { Cmd = [ "${pkgs.hello}/bin/hello" ]; };
}
#+END_SRC

Run the container:


#+BEGIN_SRC sh
$ nix-build
$ docker load < result # $ docker load < $(nix-build)
Loaded image: hello-docker:y74sb4nrhxr975xs7h83izgm8z75x5fc
$ docker run -t hello-docker:y74sb4nrhxr975xs7h83izgm8z75x5fc
#+END_SRC

More info at:

- [[https://nixos.org/manual/nixpkgs/stable/#sec-pkgs-dockerTools][dockerTools]]
- [[https://github.com/NixOS/nixpkgs/blob/master/pkgs/build-support/docker/examples.nix][dockerTools examples]]

*** Deploying NixOS using Terraform

[[https://nix.dev/tutorials/deploying-nixos-using-terraform.html][Deploying NixOS using Terraform — nix.dev documentation]]

*** Nix profile

=~/.nix-profile/bin= is in your PATH

=nix-env= only changes where the ~/.nix-profile softlink points.

#+BEGIN_SRC sh
$ readlink ~/.nix-profile
/nix/var/nix/profiles/per-user/arnau/profile

$ readlink -f ~/.nix-profile
/nix/store/snyws5v4z4cgirj5rnj8b63mhqgx14kp-user-environment
#+END_SRC

*** My first derivation

- To build: =$ nix-build default.nix=
- To install: =$ nix-env -i -f default.nix=

#+BEGIN_SRC nix
# default.nix
{ pkgs ? import <nixpkgs> {} }:

pkgs.stdenv.mkDerivation {
  name = "test.txt";
  src = ./test.txt;
  phases = [ "installPhase" ];
  installPhase = ''
    ln -s $src $out
  '';
}
#+END_SRC


** Anti-patterns

*** Unquoted URLs are bad
*** rec can loop, use let ... in
*** with attrset; .. expression

#+BEGIN_SRC nix
# instead of:
with (import <nixpkgs> {});

# try this instead:
let
  pkgs = import <nixpkgs> {};
  inherit (pkgs) curl jq;
in ...
#+END_SRC

#+BEGIN_SRC nix
# instead of:
buildInputs = with pkgs; [ curl jq ];

# try this instead:
buildInputs = builtins.attrValues {
  inherit (pkgs) curl jq;
};

# or this:
buildInputs = lib.attrVals ["curl" "jq"] pkgs
#+END_SRC

*** Pin, do not <nixpkgs>
*** attr1 // attr2

Does not work on nested attrsets:

#+BEGIN_SRC
nix-repl> :p { a = { b = 1; }; } // { a = { c = 3; }; }
{ a = { c = 3; }; }
#+END_SRC

A better way =pkgs.lib.recursiveUpdate=:

#+BEGIN_SRC
:p pkgs.lib.recursiveUpdate { a = { b = 1; }; } { a = { c = 3; }; }
{ a = { b = 1; c = 3; }; }
#+END_SRC

*** src = ./. is not reproducible


#+BEGIN_SRC nix
{ pkgs ? import <nixpkgs> {} }:

pkgs.stdenv.mkDerivation {
   name = "foobar";
   src = ./.;
}
#+END_SRC

The problem is that now your build is *no longer reproducible*, as it depends on the parent directory name.

#+BEGIN_SRC nix
{ pkgs ? import <nixpkgs> {} }:

pkgs.stdenv.mkDerivation {
   name = "foobar";
   src = builtins.path { path = ./.; name = "myproject"; };
}
#+END_SRC


** Resources

Manuals:

- [[https://nixos.org/manual/nix/stable/][Nix (manual)]]
- [[https://nixos.org/manual/nixos/stable/][NixOS (manual)]]
- [[https://nixos.org/manual/nixpkgs/stable/][Nixpkgs (manual)]]
- [[https://hydra.nixos.org/build/141547278/download/1/hydra/][Hydra (manual)]]

Guide:

- https://nix.dev/index.html
- https://github.com/nix-dot-dev/getting-started-nix-template

*** Nix

- [[https://github.com/Gabriel439/slides/blob/master/nix-internals/slides.md][nix-internals (Gabriel Gonzalez)]]

*** Nixpkgs

- [[https://discourse.nixos.org/t/difference-between-fetchtarball-fetchfromgithub-fetchgit/3279][fetchTarball vs fetchGit vs fetchFromGithub]]
- [[https://blog.flyingcircus.io/2017/11/07/nixos-the-dos-and-donts-of-nixpkgs-overlays/][The DOs and DON’Ts of nixpkgs overlays]]

**** Tutorials

- [[https://github.com/Gabriel439/haskell-nix][Nix and Haskell in production]] How to develop and build your haskell applications using Nix.
- [[https://github.com/fghibellini/nix-haskell-monorepo][Nix Haskell Monorepo Tutorial]] Recommended after /Nix and Haskell in production/)

*** NixOS

- [[https://nixos.wiki/wiki/Configuration_Collection][Collection of configurations]]
- [[https://github.com/nix-community/home-manager][Home Manager]]
- [[http://www.haskellforall.com/2018/08/nixos-in-production.html][NixOS in production]] short post summarizing what I wish I had known when I first started using NixOS in production
- [[https://awakesecurity.com/blog/deploy-software-easily-securely-using-nix-deploy/][Deploy software easily and securely using nix-deploy]]
